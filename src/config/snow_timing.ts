
// 用户在 PS 中测量时的基准宽度 (基于 20000px 测量环境)
export const PS_MEASURE_WIDTH = 20000;

// SVG 文件的原始 viewBox 宽度 (从 snow_visual.svg 的 viewBox="0 0 113374 2267" 提取)
export const SVG_VIEWBOX_WIDTH = 113374;

// 兼容旧名称
export const REFERENCE_WIDTH = PS_MEASURE_WIDTH;
export const SVG_ORIGINAL_WIDTH = SVG_VIEWBOX_WIDTH;

/**
 * 最终校准版时间-坐标映射数据 (2025-12-23)
 * 格式: HH:MM:SS:CC,PixelX
 * 
 * 校准策略:
 * - 前 120s: 线性基准 (Score + 0.2s)
 * - 120s 后: 渐进式加速 (Drift Compensation)
 * - 终点: 锁定到 215s / 28150px (确保滚过终止线)
 */
export const RAW_TIMING_DATA = `
00:00:00:20,130
00:00:03:20,649
00:00:06:20,1130
00:00:09:20,1643
00:00:12:20,1951
00:00:15:20,2205
00:00:18:20,2458
00:00:21:20,2732
00:00:24:20,3048
00:00:27:20,3366
00:00:30:20,3682
00:00:33:20,4000
00:00:36:20,4322
00:00:39:20,4646
00:00:42:20,4964
00:00:45:20,5283
00:00:48:20,5634
00:00:51:20,5938
00:00:54:20,6240
00:00:57:20,6560
00:01:00:20,6880
00:01:03:20,7198
00:01:06:20,7670
00:01:09:20,8152
00:01:12:20,8630
00:01:15:20,9110
00:01:18:20,9498
00:01:21:20,9768
00:01:24:20,10040
00:01:27:20,10334
00:01:30:20,10794
00:01:33:20,11274
00:01:36:20,11756
00:01:39:20,12294
00:01:42:20,12680
00:01:45:20,12998
00:01:48:20,13316
00:01:51:20,13718
00:01:54:20,14388
00:01:57:20,15026
00:02:00:20,15660
00:02:03:18,16220
00:02:06:16,16854
00:02:09:14,17490
00:02:12:12,18126
00:02:15:10,18662
00:02:18:08,19208
00:02:21:05,19682
00:02:24:02,19976
00:02:27:00,20456
00:02:29:95,20936
00:02:32:90,21415
00:02:35:85,21800
00:02:38:80,22075
00:02:41:75,22346
00:02:44:70,22640
00:02:47:65,23100
00:02:50:60,23682
00:02:53:55,24060
00:02:56:50,24600
00:02:59:45,24986
00:03:02:40,25304
00:03:05:35,25620
00:03:08:30,26060
00:03:11:25,26310
00:03:14:20,26586
00:03:17:15,26838
00:03:20:10,26974
00:03:23:05,27108
00:03:26:00,27588
00:03:28:90,28070
00:03:35:00,28150
`;

export interface TimingPoint {
  time: number; // 秒数
  x: number;    // 像素坐标
}

/**
 * 将 HH:MM:SS:CC 格式解析为秒数 (float)
 * CC 是厘秒 (1/100 秒)
 */
function timeToSeconds(timeStr: string): number {
  const [hh, mm, ss, cc] = timeStr.split(':').map(Number);
  return hh * 3600 + mm * 60 + ss + cc / 100;
}

/**
 * 解析原始字符串数据并按时间排序
 */
export function parseTimingData(raw: string): TimingPoint[] {
  return raw
    .trim()
    .split('\n')
    .filter(line => line.trim() !== '')
    .map(line => {
      const [timeStr, xStr] = line.split(',');
      return {
        time: timeToSeconds(timeStr.trim()),
        x: parseFloat(xStr.trim())
      };
    })
    .sort((a, b) => a.time - b.time);
}
