# 项目开发日志 -- 重大问题备忘录：乐谱与播放头对齐（声画同步）

**记录时间**：2025-12-22
**版本**：v1.0
**主题**：解决乐谱（SVG）滚动与 MIDI 播放的像素级对齐及声画同步问题。

---

## 1. 问题演进及错误回溯（按时间顺序）

### 2025-12-22 上午：初始对齐失败

- **现象**：初步实现了基于时间插值的乐谱滚动，但发现起始位置即存在严重偏移，且滚动速度与音乐完全脱节。
- **初期错误**：
  1.  **残留手动补偿**：代码中保留了旧版本的 `-322px` 全局偏移量，导致系统无法仅信任测量数据。
  2.  **定位逻辑冲突**：混用了 CSS `left-1/2` 和 JS 计算的 `translateX`，导致参考点（Anchor Point）在不同分辨率下漂移。
  3.  **容器宽度误区**：计算位移时参考了 `window.innerWidth`，而实际容器（Section）受到了 `max-w-6xl`（约 1152px）的物理限制。

### 2025-12-22 下午：坐标映射与缩放迷局

- **现象**：修复起始点后，乐谱滚动速度仍然比音乐快 1.5 倍左右。
- **错误分析**：
  1.  **基准参数失效**：设定 `REFERENCE_WIDTH = 20000` 作为基准，但未考虑到用户在 Photoshop (PS) 中的测量环境与 SVG 原始 `viewBox` (113374) 之间的比例关系。
  2.  **SVG 比例误判**：曾试图将基准改为 `113374`，结果导致乐谱滚动极其缓慢。这说明映射表坐标是基于 PS 的“缩放后宽度”而非“原始几何宽度”。
  3.  **过渡滞后**：CSS 中保留了 `transition: 0.05s linear`，在物理引擎高频轮询（Ref/Raf）驱动下，这一微小的延迟会导致视觉上的“漂移感”和“不实时”。

### 2025-12-22 晚上：同步速度攻坚

- **现象**：通过多次迭代微调 `PS_MEASURE_WIDTH`（29400 -> 27200 -> 26000 -> 28000 -> 28500），同步效果逐渐逼近完美，但末端仍有 1-3 秒的累积误差。
- **关键发现**：
  1.  **惯性轮（Inertia Engine）逻辑验证**：确认了 MIDI 播放与乐谱滚动共享 `currentSeconds`。只要该时间轴统一，且映射比例正确，两者天然同步。
  2.  **分段偏移校准**：发现单一的全局缩放常数无法解决由于测量精度、渲染亚像素误差导致的累积偏差。

---

## 2. 工程方法与设计方案详情

### 核心算法：自适应线性插值映射 (Adaptive Linear Mapping)

1.  **数据层**：
    - 构建 `timingData` 映射表：`{ time: number, x: number }[]`。
    - 解析函数 `parseTimingData` 处理 `HH:MM:SS:CC` 格式，将厘秒 (CC) 精确转换为秒。
2.  **计算层**：
    - **定位锚点**：根据当前物理时间 `t`，在映射表中检索 `prev` 和 `next` 两个锚点。
    - **插值计算**：使用线性公式计算出在 PS 基准下的理论像素位置 $X_{ps}$：
      $$X_{ps} = X_{prev} + (X_{next} - X_{prev}) \times \frac{t - T_{prev}}{T_{next} - T_{prev}}$$
    - **空间转换**：将 PS 映射像素转换为浏览器实时宽度像素：
      $$X_{browser} = X_{ps} \times \frac{CurrentRenderedWidth}{PS\_MEASURE\_WIDTH}$$
3.  **渲染层**：
    - **物理锚点固定**：视口中心线（红线）锁定在 `50%`。
    - **即时位移**：`transform: translateX(${GlobalOffset - X_browser}px)`。
    - **零延迟方案**：禁用 CSS `transition` 和 `will-change-transform` 以外的所有干预，完全交由物理引擎驱动更新。

### 精准参数（已验证）：

- **PS_MEASURE_WIDTH**: `28500` (基于当前 SVG 在 PS 环境下的测量精度修正值)。
- **Global Offset**: `-60px` (对齐第一个音符/乐谱起点的精准微调量)。

---

## 3. 经验教训与未来指导要件

### 后续应记住的关键要点：

1.  **彻底的数据驱动**：

    - **原则**：如果存在手动对齐表，则**必须**移除所有硬编码的魔法数字（Magic Numbers）或默认偏移。
    - **操作**：在启动阶段，先通过第一个点 $(T_0, X_0)$ 强制归零，后续所有位移均基于相对增量。

2.  **基准系一致性**：

    - **原则**：测量环境（PS/AI）的尺寸与前端渲染环境（SVG/Img）尺寸往往不一致。
    - **操作**：必须显式定义一个 `REFERENCE_WIDTH`，并计算 `ScaleRatio`。

3.  **不要与物理引擎“争抢”控制权**：

    - **原则**：当使用 `requestAnimationFrame` 或高性能物理轮询时，**严禁**开启 CSS 的 `transition`，否则会产生难以排查的亚像素延迟，导致“越跑越偏”。

4.  **动态自适应（ResizeObserver）**：

    - **原则**：乐谱图片是流式的，宽度随视口变化。
    - **操作**：必须使用 `ResizeObserver` 或 `onLoad` 获取真实的渲染像素宽度 `getBoundingClientRect().width`，而不是预估值。

5.  **分段校准策略**：
    - **原则**：对于长达数分钟的同步，单一全局比例因子极易产生累积误差。
    - **未来扩展**：若需进一步提高精度，应采用**分段线性校准 (Piecewise Linear Calibration)**，即每一对锚点之间单独计算其段内的 `scaleFactor`。

---

_记录人：Antigravity AI 编码助手_
_注：本备忘录旨在作为本课题“声画一致性”最终解决方案的技术规范。_
